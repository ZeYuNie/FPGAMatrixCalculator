# Matrix Input Handler 模块

## 功能概述

`matrix_input_handler` 模块用于处理"matrix input"模式下的矩阵输入操作。它从缓冲RAM（`num_storage_ram`）读取矩阵数据，并将其写入矩阵存储管理器（`matrix_storage_manager`）。

该模块支持两种输入格式：
1. **命名矩阵**：用户指定矩阵ID和名称
2. **匿名矩阵**：系统自动分配空闲的矩阵ID

## 数据处理规则

**重要**：模块总是从缓冲RAM读取恰好 m×n 个矩阵数据元素：

1. **数据不足 m×n 个**：剩余位置读取的值将作为矩阵数据（建议使用前清空缓冲区，使不足部分自动补零）
2. **数据超过 m×n 个**：超出部分会被自动忽略，不会写入矩阵存储

**建议**：在每次输入新矩阵数据前，通过手动清空缓冲区确保未使用位置为0，从而实现自动补零功能。

## 数据格式

### 格式1：命名矩阵

缓冲RAM中的数据格式（每个元素为32位有符号整数）：
```
-1, 矩阵ID, 名称字[0], 名称字[1], 行数, 列数, 数据[0], 数据[1], ..., 数据[m×n-1]
```

**说明**：
- 第一个字为 `-1`（0xFFFFFFFF），标识这是命名矩阵
- 第二个字为矩阵ID（1-7）
- 接下来2个字为矩阵名称（8个ASCII字符）：
  - 名称字[0] = {name[0], name[1], name[2], name[3]} (大端序)
  - 名称字[1] = {name[4], name[5], name[6], name[7]} (大端序)
- 行数和列数各占1个字（使用低8位）
- 然后是 m×n 个矩阵数据元素

**示例**：
```
输入：-1, 3, 0x01020304, 0x05060708, 2, 3, 8, 9, 0, 8, 0, 9
表示：
- 矩阵ID = 3
- 名称 = ASCII {1, 2, 3, 4, 5, 6, 7, 8}
- 2行3列矩阵：[[8, 9, 0], [8, 0, 9]]

数据不足示例（假设缓冲区已清零）：
输入：-1, 2, 0x41424344, 0x45464748, 2, 3, 1, 2
表示：2×3矩阵，但只提供2个数据
实际存储：[[1, 2, 0], [0, 0, 0]]（后4个位置读到0）

数据超出示例：
输入：-1, 4, 0x4D4E4F50, 0x51525354, 2, 2, 10, 20, 30, 40, 50, 60
表示：2×2矩阵，但提供了6个数据
实际存储：[[10, 20], [30, 40]]（后2个数据被忽略）
```

### 格式2：匿名矩阵

缓冲RAM中的数据格式：
```
行数, 列数, 数据[0], 数据[1], ..., 数据[m×n-1]
```

**说明**：
- 第一个字为行数（使用低8位）
- 第二个字为列数（使用低8位）
- 系统自动检测ID 1-7中第一个空闲槽位
- 矩阵名称设为全0
- 然后是 m×n 个矩阵数据元素

**示例**：
```
输入：2, 3, 6, 7, 8, 6, 5, 4
表示：
- 系统查找空闲槽位（例如ID=4）
- 2行3列矩阵：[[6, 7, 8], [6, 5, 4]]
- 名称为空

数据不足示例（假设缓冲区已清零）：
输入：3, 2, 5, 10, 15
表示：3×2矩阵，但只提供3个数据
实际存储：[[5, 10], [15, 0], [0, 0]]（后3个位置读到0）

数据超出示例：
输入：2, 2, 1, 2, 3, 4, 5, 6, 7, 8
表示：2×2矩阵，但提供了8个数据
实际存储：[[1, 2], [3, 4]]（后4个数据被忽略）
```

## 参数

无可配置参数。

## 接口定义

### 控制信号

| 信号 | 方向 | 位宽 | 说明 |
|------|------|------|------|
| `clk` | 输入 | 1 | 时钟信号 |
| `rst_n` | 输入 | 1 | 异步低电平复位 |
| `start` | 输入 | 1 | 启动信号（单周期脉冲） |
| `error` | 输出 | 1 | 错误标志，拉高后持续直到复位 |
| `busy` | 输出 | 1 | 忙标志，处理过程中为高 |
| `done` | 输出 | 1 | 完成标志 |

### 缓冲RAM读接口

| 信号 | 方向 | 位宽 | 说明 |
|------|------|------|------|
| `buf_rd_addr` | 输出 | 11 | 缓冲RAM读地址 |
| `buf_rd_data` | 输入 | 32 | 缓冲RAM读数据（1周期延迟） |

### 矩阵存储管理器写接口

| 信号 | 方向 | 位宽 | 说明 |
|------|------|------|------|
| `write_request` | 输出 | 1 | 写请求信号 |
| `write_ready` | 输入 | 1 | 写就绪标志 |
| `matrix_id` | 输出 | 3 | 矩阵ID (1-7) |
| `actual_rows` | 输出 | 8 | 实际行数 |
| `actual_cols` | 输出 | 8 | 实际列数 |
| `matrix_name[0:7]` | 输出 | 8×8 | 矩阵名称（8字节） |
| `data_in` | 输出 | 32 | 写入数据 |
| `data_valid` | 输出 | 1 | 数据有效标志 |
| `write_done` | 输入 | 1 | 写完成标志 |
| `writer_ready` | 输入 | 1 | 写模块就绪标志 |

### 矩阵存储管理器读接口

用于检测空闲槽位：

| 信号 | 方向 | 位宽 | 说明 |
|------|------|------|------|
| `storage_rd_addr` | 输出 | 14 | 存储RAM读地址 |
| `storage_rd_data` | 输入 | 32 | 存储RAM读数据 |

## 工作流程

### 命名矩阵处理流程

1. 接收 `start` 信号
2. 从缓冲RAM地址0读取第一个字
3. 检测到 `-1`，识别为命名矩阵
4. 依次读取：矩阵ID、名称（2个字）、行数、列数
5. 验证矩阵ID是否在1-7范围内
6. 向存储管理器发起写请求
7. 逐个读取并发送矩阵数据
8. 等待写完成，设置 `done` 标志

### 匿名矩阵处理流程

1. 接收 `start` 信号
2. 从缓冲RAM地址0读取第一个字（行数）
3. 读取列数
4. 从ID=1开始检查存储管理器中的空闲槽位
   - 读取每个矩阵的元数据（地址0）
   - 如果 `rows == 0 && cols == 0`，则该槽位为空
5. 找到第一个空闲槽位
6. 设置矩阵名称为全0
7. 向存储管理器发起写请求
8. 逐个读取并发送矩阵数据
9. 等待写完成，设置 `done` 标志

## 错误处理

以下情况会触发 `error` 信号：

1. **无效的矩阵ID**：命名矩阵的ID不在1-7范围内
2. **无可用槽位**：匿名矩阵查找时ID 1-7都已被占用
3. 错误信号一旦拉高会持续保持，直到模块复位

## 时序特性

- **缓冲RAM读延迟**：1个时钟周期
- **存储RAM读延迟**：1个时钟周期（用于检测空闲槽位）
- **处理周期**：取决于矩阵大小和存储管理器的响应速度

## 使用示例

### 写入命名矩阵

```systemverilog
// 假设缓冲RAM已填充以下数据：
// addr[0] = -1 (0xFFFFFFFF)
// addr[1] = 3 (矩阵ID)
// addr[2] = 0x01020304 (name[0-3])
// addr[3] = 0x05060708 (name[4-7])
// addr[4] = 2 (行数)
// addr[5] = 3 (列数)
// addr[6] = 8, addr[7] = 9, ..., addr[11] = 9

// 启动处理
@(posedge clk);
start <= 1'b1;
@(posedge clk);
start <= 1'b0;

// 等待完成
wait(done);
$display("Matrix written successfully");
```

### 写入匿名矩阵

```systemverilog
// 假设缓冲RAM已填充以下数据：
// addr[0] = 2 (行数)
// addr[1] = 3 (列数)
// addr[2] = 6, addr[3] = 7, ..., addr[7] = 4

// 启动处理
@(posedge clk);
start <= 1'b1;
@(posedge clk);
start <= 1'b0;

// 等待完成
wait(done);
if (error) begin
    $display("Error occurred");
end else begin
    $display("Matrix written to slot %d", matrix_id);
end
```

## 状态机

模块使用以下状态：

- `IDLE`：空闲状态，等待启动
- `READ_FIRST`/`WAIT_FIRST`：读取第一个字并判断类型
- `READ_ID`/`WAIT_ID`：读取矩阵ID（命名矩阵）
- `READ_NAME_0`/`WAIT_NAME_0`：读取名称字0
- `READ_NAME_1`/`WAIT_NAME_1`：读取名称字1
- `READ_ROWS`/`WAIT_ROWS`：读取行数
- `READ_COLS`/`WAIT_COLS`：读取列数
- `FIND_EMPTY_SLOT`：查找空闲槽位（匿名矩阵）
- `WAIT_EMPTY_CHECK`：等待空闲槽位检查结果
- `INITIATE_WRITE`：发起写请求
- `WAIT_WRITER_READY`：等待写模块就绪
- `READ_DATA`/`WAIT_DATA`：读取矩阵数据
- `STREAM_DATA`：发送数据到存储管理器
- `WAIT_WRITE_DONE`：等待写完成
- `DONE_STATE`：完成状态
- `ERROR_STATE`：错误状态

## 地址计算

空闲槽位检测使用精确的地址计算，与 `matrix_address_getter` 完全一致：

| 矩阵ID | 基地址 | 计算方式 |
|--------|--------|----------|
| 0 | 0 | 0 × 1152 |
| 1 | 1152 | 1 × 1152 |
| 2 | 2304 | 2 × 1152 |
| 3 | 3456 | 3 × 1152 |
| 4 | 4608 | 4 × 1152 |
| 5 | 5760 | 5 × 1152 |
| 6 | 6912 | 6 × 1152 |
| 7 | 8064 | 7 × 1152 |

每个槽位的第一个地址存储元数据：`{rows[7:0], cols[7:0], 16'b0}`

## 注意事项

1. **单次运行**：每次 `start` 信号只处理一次矩阵输入
2. **错误持续**：错误标志一旦拉高会持续到复位
3. **缓冲准备**：启动前确保缓冲RAM已正确填充数据
4. **缓冲区清零**：**强烈建议**在输入新矩阵前手动清空缓冲区，确保数据不足时剩余位置为0
5. **数据处理**：
   - 总是读取恰好 m×n 个元素
   - 数据不足时，剩余位置的值取决于缓冲区内容（清零后为0）
   - 数据超出时，自动忽略超出 m×n 的部分
6. **ID范围**：有效矩阵ID为1-7（ID 0保留或用于系统）
7. **行列限制**：行数和列数应符合存储管理器的要求（最大32×32）
8. **地址精确性**：地址计算使用精确的 `matrix_id × 1152` 公式

## 测试验证

测试文件：`modules/matrix_input_handler/sim/matrix_input_handler_tb.sv`

测试用例应包括：
- 命名矩阵写入
- 匿名矩阵写入
- 无效矩阵ID错误
- 无可用槽位错误
- 不同矩阵大小
- 边界条件测试
- **数据不足测试**（验证缓冲区清零后自动补零）
- **数据超出测试**（验证超出部分被正确忽略）